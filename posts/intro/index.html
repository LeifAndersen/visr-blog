<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introducing Visual and Interactive-Syntax realized (VISr) for ClojureScript (and JavaScript)</title>
    <meta name="description" content="All about Visual and Interactive Syntax">

    <link rel="stylesheet" href="/css/index.css">
    <link rel="stylesheet" href="/css/prism-base16-monokai.dark.css">
    <link rel="stylesheet" href="/css/prism-diff.css">
    <link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="The VISr Blog">
    <link rel="alternate" href="/feed/feed.json" type="application/json" title="The VISr Blog">
  </head>
  <body>
    <header>
      <h1 class="home"><a href="/">The VISr Blog</a></h1>
      <ul class="nav">
      </ul>
    </header>

    <main class="tmpl-post">

      <h1>Introducing Visual and Interactive-Syntax realized (VISr) for ClojureScript (and JavaScript)</h1>

<time datetime="2022-01-06">06 Jan 2022</time>
<a href="/tags/tutorial/" class="post-tag">tutorial</a>

<p>Visual and interactive-syntax is a type of language-oriented programming that
allows developers to use, view, and edit portions of a textual program with
graphics. Using interactive-syntax provides the benefits of a graphical
programming language, while keeping all of the benefits of a purely textual
language. For example, the following is an example of a small network embedded
in a program:</p>
<img alt="Graphical network embedded in text" loading="lazy" decoding="async" src="/posts/intro/dRGrWU2Nnk-300.png" width="600" height="337" srcset="/posts/intro/dRGrWU2Nnk-300.png 300w, /posts/intro/dRGrWU2Nnk-600.png 600w" sizes="100vw">
<p>Interactive-syntax is backed by human readable code; the visual components
exists purely when writing and editing code. This backing means all of the tools
involved in software development work with interactive-syntax extensions. For
example:</p>
<ul>
<li>version control, such as git, works with interactive-syntax;</li>
<li>programs using interactive-syntax can be written and edited with your favorite
text editor or IDE;</li>
<li>cut/copy/paste works with interactive-syntax using your operating system's
native clipboard;</li>
<li>code analysis tools, like diff and refactor, still work with
interactive-syntax; and</li>
<li>you can use interactive-syntax in any language or environment that supports
language-oriented programming.</li>
</ul>
<p>To learn more about interactive-syntax, watch <a href="https://www.youtube.com/watch?v=8htgAxJuK5c">this video</a> or read
<a href="https://dl.acm.org/doi/10.1145/3428290">the accompanying paper</a>.</p>
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/8htgAxJuK5c" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p><a href="https://visr.pl">VISr (Visual and Interactive-Syntax realized) for ClojureScript</a> is a
practical implementation of interactive-syntax in web browsers. The VISr
environment is a full-featured IDE that supports interactive-syntax components
called VISrs. Additionally, the VISr environment comes with a package manager
that supports <a href="https://www.npmjs.com/">NPM packages</a>.</p>
<p>This article is a brief introduction to both the VISr environment and the
components that make up a VISrs. It discusses how to insert a VISr into code,
how to manipulate a VISr, and how to create a new types of VISr. Future articles
will discuss more advanced uses such as integrating NPM packages and using VISrs
in other languages.</p>
<!-- more -->
<h2 id="getting-started-with-visr" tabindex="-1">Getting started with VISr <a class="direct-link" href="#getting-started-with-visr" aria-hidden="true">#</a></h2>
<p>Start by going to <a href="https://visr.pl">visr.pl</a>, which is a web-based IDE that directly
supports VISrs. Once in the IDE, press <code>Insert VISr</code> to place a VISr at the
current cursor position. This VISr contains two buttons:</p>
<ul>
<li>clicking the first displays the VISr's visual representation, and</li>
<li>clicking the second shows its textual representation.</li>
</ul>
<img alt="VISr" loading="lazy" decoding="async" src="/posts/intro/29GkAMLS2A-48.png" width="48" height="29">
<p>Opening the code shows that the new VISr is an instance of
<code>visr.core/empty-visr</code>, a default VISr provided by the IDE. This VISr expects a
map with the key <code>:message</code> to display in the visual view. Changing the value
associated with <code>:message</code> changes what is displayed, in this case &quot;Endless
Possibility&quot;:</p>
<img alt="Open VISr" loading="lazy" decoding="async" src="/posts/intro/4FuFkW5abk-300.png" width="300" height="43">
<p>Remember that, although this VISr is displayed graphically, it still exists as
human-readable text. One way to see this text is by copying and pasting the
VISr. A copy of the same VISr will appear when it is placed back into the IDE.
However, pasting it into other text editors that do not natively support VISrs
yields the following human readable, and editable, text:</p>
<pre class="language-clojurescript"><code class="language-clojurescript"><span class="token operator">^</span><span class="token punctuation">{</span><span class="token symbol">:editor</span> visr.core/empty-visr<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token function">visr.core/empty-visr+elaborate</span><br>                                 <span class="token punctuation">{</span><span class="token symbol">:message</span> <span class="token string">"Endless Possibility"</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<p>This operation works in reverse too. Writing out similar text and pasting it
into <a href="https://visr.pl">visr.pl</a> yields its visual representation.</p>
<h2 id="making-a-new-visr" tabindex="-1">Making a new VISr <a class="direct-link" href="#making-a-new-visr" aria-hidden="true">#</a></h2>
<p>The <code>defvisr</code> form creates a VISr type. This form expects two methods:</p>
<ol>
<li>a <code>render</code> method that provides visualization and interaction when code is
edited, and</li>
<li>an <code>elaborate</code>/<code>elaborate-fn</code> method that gives the VISr compile-time and
run-time semantics.</li>
</ol>
<p>The following is the signature for a simple VISr type:</p>
<pre class="language-clojurescript"><code class="language-clojurescript"><span class="token punctuation">(</span><span class="token keyword">ns</span> example.core<span class="token punctuation">)</span><br><br><span class="token punctuation">(</span><span class="token function">defvisr</span> Counter<br>  <span class="token punctuation">(</span><span class="token function">elaborate-fn</span> <span class="token punctuation">[</span>this<span class="token punctuation">]</span> <span class="token string">"TODO-elaborate"</span><span class="token punctuation">)</span><br>  <span class="token punctuation">(</span><span class="token function">render</span> <span class="token punctuation">[</span>this<span class="token punctuation">]</span> <span class="token string">"TODO-render"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>This example uses <code>elaborate-fn</code>, a simplified version of <code>elaborate</code> that gives
the <code>VISr</code> the same semantics as a function application. It also allows the
<code>defvisr</code> form to work in the same file as the VISr itself.</p>
<img alt="Example of elaborate-fn semantics" loading="lazy" decoding="async" src="/posts/intro/Cpim81h-RI-300.png" width="600" height="337" srcset="/posts/intro/Cpim81h-RI-300.png 300w, /posts/intro/Cpim81h-RI-600.png 600w" sizes="100vw">
<h2 id="the-render-method-for-edit-time-semantics" tabindex="-1">The Render Method for Edit-Time Semantics <a class="direct-link" href="#the-render-method-for-edit-time-semantics" aria-hidden="true">#</a></h2>
<p>The <code>render</code> method is given the VISr state <a href="https://clojure.org/reference/atoms">as an atom</a>; updating this
atom also updates the code to reflect the new state. The return value for
<code>render</code> must be a <a href="https://reagent-project.github.io/">Reagent form</a> that is the visual view for the VISr.
A render method for a counter VISr might look as follows:</p>
<pre class="language-clojurescript"><code class="language-clojurescript"><span class="token punctuation">(</span><span class="token function">render</span> <span class="token punctuation">[</span>this<span class="token punctuation">]</span><br>  <span class="token punctuation">[</span><span class="token symbol">:button</span> <span class="token punctuation">{</span><span class="token symbol">:on-click</span> <span class="token operator">#</span><span class="token punctuation">(</span><span class="token function">swap!</span> this inc<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">@</span>this<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>
<p>And in action:</p>
<img alt="Simple Count Example" loading="lazy" decoding="async" src="/posts/intro/gEM9kSBBOJ-300.png" width="600" height="337" srcset="/posts/intro/gEM9kSBBOJ-300.png 300w, /posts/intro/gEM9kSBBOJ-600.png 600w" sizes="100vw">
<p>This VISr doesn't match the theme of the page; it also requires the state to be
a single number. Using <a href="https://react-bootstrap.github.io/">React Bootstrap</a> and Reagent cursors
fixes both of these issues:</p>
<pre class="language-clojurescript"><code class="language-clojurescript"><span class="token punctuation">(</span><span class="token keyword">ns</span> example.core<br>  <span class="token punctuation">(</span><span class="token symbol">:require</span> <span class="token punctuation">[</span>reagent.core <span class="token symbol">:refer</span> <span class="token punctuation">[</span>cursor<span class="token punctuation">]</span><span class="token punctuation">]</span><br>            <span class="token punctuation">[</span>react-bootstrap <span class="token symbol">:refer</span> <span class="token punctuation">[</span>Button<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><br><span class="token punctuation">(</span><span class="token function">defvisr</span> Counter<br>  <span class="token punctuation">(</span><span class="token function">elaborate-fn</span> <span class="token punctuation">[</span>this<span class="token punctuation">]</span> <span class="token string">"TODO-elaborate"</span><span class="token punctuation">)</span><br>  <span class="token punctuation">(</span><span class="token function">render</span> <span class="token punctuation">[</span>this<span class="token punctuation">]</span><br>    <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>count <span class="token punctuation">(</span><span class="token function">cursor</span> this <span class="token punctuation">[</span><span class="token symbol">:count</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><br>      <span class="token punctuation">(</span><span class="token keyword">when-not</span> <span class="token operator">@</span>count <span class="token punctuation">(</span><span class="token function">reset!</span> count <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>      <span class="token punctuation">[</span><span class="token symbol">:></span> Button <span class="token punctuation">{</span><span class="token symbol">:on-click</span> <span class="token operator">#</span><span class="token punctuation">(</span><span class="token function">swap!</span> count inc<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">@</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<h2 id="elaboration-and-run-time-semantics" tabindex="-1">Elaboration and Run-Time Semantics <a class="direct-link" href="#elaboration-and-run-time-semantics" aria-hidden="true">#</a></h2>
<p>The elaborate method takes the VISr state, and is expected to provide a
compile-time or run-time semantics. In the simplified case of <code>elaborate-fn</code>,
the VISr semantics takes the form of a function application:</p>
<pre class="language-clojurescript"><code class="language-clojurescript"><span class="token punctuation">(</span><span class="token function">elaborate-fn</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:keys</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span> count<span class="token punctuation">)</span></code></pre>
<p>This <code>elaborate</code> method expects a dictionary with the key <code>:count</code> and returns
the value associated with that key. It makes use of <a href="https://clojure.org/guides/destructuring">ClojureScript's
Destructuring</a> for brevity. The following code is equivalent:</p>
<pre class="language-clojurescript"><code class="language-clojurescript"><span class="token punctuation">(</span><span class="token function">elaborate-fn</span> <span class="token punctuation">[</span>this<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">get</span> this <span class="token symbol">:count</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<h2 id="putting-it-all-together" tabindex="-1">Putting it all together <a class="direct-link" href="#putting-it-all-together" aria-hidden="true">#</a></h2>
<p>The final result is:</p>
<pre class="language-clojurescript"><code class="language-clojurescript"><span class="token punctuation">(</span><span class="token keyword">ns</span> test.core<br>  <span class="token punctuation">(</span><span class="token symbol">:require</span> <span class="token punctuation">[</span>reagent.core <span class="token symbol">:refer</span> <span class="token punctuation">[</span>cursor<span class="token punctuation">]</span><span class="token punctuation">]</span><br>            <span class="token punctuation">[</span>react-bootstrap <span class="token symbol">:refer</span> <span class="token punctuation">[</span>Button<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><br><span class="token punctuation">(</span><span class="token function">defvisr</span> Counter<br>  <span class="token punctuation">(</span><span class="token function">elaborate-fn</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:keys</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span> count<span class="token punctuation">)</span><br>  <span class="token punctuation">(</span><span class="token function">render</span> <span class="token punctuation">[</span>this<span class="token punctuation">]</span><br>    <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>count <span class="token punctuation">(</span><span class="token function">cursor</span> this <span class="token punctuation">[</span><span class="token symbol">:count</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><br>      <span class="token punctuation">(</span><span class="token keyword">when-not</span> <span class="token operator">@</span>count <span class="token punctuation">(</span><span class="token function">reset!</span> count <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>      <span class="token punctuation">[</span><span class="token symbol">:></span> Button <span class="token punctuation">{</span><span class="token symbol">:on-click</span> <span class="token operator">#</span><span class="token punctuation">(</span><span class="token function">swap!</span> count inc<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">@</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>Here is the VISr in action:</p>
<img alt="Full Count Example" loading="lazy" decoding="async" src="/posts/intro/H3V63THsXG-300.png" width="600" height="337" srcset="/posts/intro/H3V63THsXG-300.png 300w, /posts/intro/H3V63THsXG-600.png 600w" sizes="100vw">
<p>That's all there is to it. From here, you can go to <a href="https://visr.pl">visr.pl</a> to make your
own programs using VISr. You can also <a href="https://study.visr.pl">take this survey</a>, which contains
more advanced example uses for VISr. If you find any bugs or want to contribute,
you can also head to <a href="https://github.com/LeifAndersen/interactive-syntax-clojure">the visr project page</a>.</p>
<p>Thanks for reading, happy coding!</p>

<hr>
<ul><li>Next: <a href="/posts/use-deps/">Using Dependencies in VISr</a></li>
</ul>

    </main>

    <footer></footer>

    <!-- Current page: /posts/intro/ -->
  </body>
</html>
